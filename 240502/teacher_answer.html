<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    // 따라해봅시다.
    // 첫 시작은 언제나 일부로라도 어렵게! 굉장히 비효율적이지만, 이해의 누락을 없앨 수 있다.
    // 이해에 누락이 생겼다면? 바로 확인 할 수 있는 방법을 알려주는 것.
    
    
    
    function addItem(array, item, index) {
      // 잠시 진실을 주석처리하고 새로 변수로 할당한 newArray를 return으로 넣어서 작동이 되나 확인을 해본다.
      // 확인이 되었다. 그럼 이제 다시 공란으로 만들어주자.
      let newArray = [];
      // teacher : newArray라는 변수를 배열로 할당했네? 아 그럼 문자열은 아닌가보다.
      
      // teacher : 함수가 선언되어있네? 몰라 일단 넘어가 얘는 나중에 필요하면 보면 되지.

      // 조건이 크거나 같을 때 까지, 반복해라 라는 말이 있다. 여기서 무엇을 추론할 수 있는가?
      // 무언가 추가가 되겠구나.
      for( let i = 0; i <= array.length; i++) {
        // teacher : 조건문 
        // teacher : array가 있네? array가 위에있네? 아 직관적으로 매개변수로 array를 받아온다는 의미구나 라고 캐치!
        // teacher : 반복문이 돌고, length, "array"라는 이름이 무엇인지 모르겠음. 찾아보니 매개변수에 있네?
        // teacher : 높은 확률로 array라는 놈은 배열일 것이다.

        function isIndexAfterInsertionPoint(currentIndex) {
          // else if에 함수를 실행하러 왔다.
          return currentIndex > index;
          // 매개변수로 할당된 것이 index보다 크다면! 여기서 index는 num타입이므로 currentIndex또한 숫자를 받아옴을 알 수 있다.
          // 그리고 else if의 조건을 보았을 때 true를 굳이 지정한 것으로 보아 이 함수가 불리언타입을 리턴함을 알 수 있다.
        }

        if( i === index ) {
          // teacher : 뭐야 index어디있어? 뭐야 index도 매개변수였네. 
          // teacher : 내가 생각하는게 index가 아니네 그럼 i랑 같아지려면 숫자를 비교하려는 if문 때문에 만들어 놓은거네?
          
          // 이것을 확인하기위해 index자리에 2를 주었다 그렇다면 키위가 로그 될 것이다.
          // 확인결과 공욱재 미남 키위 키위 인데, 키위가 순서대로 반복하다가 36줄이 먼저 실행됬음을 확인 할 수 있었다.
          // 이것으로 나는 이 index가 숫자를 받아옴을 알 수 있다.
          // console.log('나 키위 아니야');
          // teacher : 난 키위가 아니니까 내 생각과 맞다면 실행되도록 사용했다.

          // undefined가 나오는 이유? newArray의 다른 요소들은 지정된 것이 없으니까.
          // 그렇다면 다른 것도 채우겠지? 그리고 크거나 작은거니까 하나가 추가될 거야.
          // 원하는 자리에 추가하기 위해서 이것을 사용하는 거구나! 라고 추측할 수 있지 않을까?
          // 매개변수 index순번에 item의 프로퍼티를 넣기 위한거야.
          // 그러면서 기존의 배열의 값들은 유지하고 싶어서 length와 작거나 같다라고 지정한거고.
          newArray[i] = item;
          // teacher : 뭐야 newArray에 i번째에 할당은 알겠는데 item이 뭐지? 찾아보니까 매개변수에 있네?
          // teacher : 테스트를 위해 "나 키위 아니야!"를 매개변수로 넣었다.

          // 함수가 나왔으니까 함수를 확인해야 겠지?
        } else if (isIndexAfterInsertionPoint(i) === true) {

          // 이 함수를 하면 무엇인가 array.length보다 크다는 것이다 i가 즉 추가가 된 이후의 것들을 넣어야한다.
          newArray[i] = array[ i - 1 ];
          // else if로 실행되는 newArray[i]는 이미 array보다 값이 하나 추가된 상태이다.
          // 그리고 array[i]는 마지막에 uncaught를 띄울 것이다. 왜냐하면 그것이 배열의 특성이니까 
          // 그래서 array[ i - 1 ]을 할 필요가 있다.

        } else {
          // newArray[i]에 array[i]를 할당해줘.
          // 그러면 마지막 값은 undefined가 되버릴 것이다. 
          // 왜냐하면 이 반복문의 조건은 array.length니까 array의 배열보다 1개가 많다.
          // 1개를 추가하는 것이 if의 조건을 만족하는 것이었으니까 그럼 else if를 추가해야겠지?
          newArray[i] = array[i];
          // teacher : index 와 i가 같이 매칭이 되지 않으면 실행해줘.
        }
        
        // 왜 array의 length를 읽지 못할까?
        // 이유는 간단했다, 밑의 for문에 매개변수를 추가하지 않았기 때문이다.
        // 아까 원래대로 돌리지않고 addItem함수의 length를 조건문으로 넣었기 때문에 발생한 오류였다.
        // 그런데 이제 또 새로운 의문이 생겼다.
        // 어째서 이놈은 5번 실행이 되는가?
        // 이번에도 이유를 알았다. 밑에 addItem()을 조건으로 넣었는데 그래서 인지 이게 실행이 되버린다.
        // updatePlanet을 할당할 때 함수가 호출되서 호출되는 함수가 실행되는 곳은 여기여서 콘솔창에는
        // 여기서 실행이 된다고 나오는구나!
        // console.log(newArray);

        // 오류가 찍히는데 이유는 array는 array.length와 같은 값인 3에 해당하는 자리에 요소가 없기 때문이다.
        // console.log(array[i]);
        // teacher : 한번 확인할겸 돌려보자.
        // teacher : 테스트가 끝났으니까 일단 지워버리기. // 나는 주석처리.
      }

      // 문자열을 리턴했고 이것이 updatePlanet에 할당했으므로, 공 욱 재 미 남 이 한글자씩 콘솔창에 로그될 것이다.
      // 근거는 리턴이 있다는 것을 알고 있기 때문에, 리턴 값을매겨서 일단 확인을 한다. 내 생각이 맞는지.
      return newArray; //"공욱재미남";
      // teacher : 지금 본인이 아는 형태까지만 확인을 한다! 가장 기본형태로. 이 함수가 실행 하는지
      // teacher : 내가 아는만큼만 적어야 합니다.
      // teacher : 지금 이 return "공욱재미남"으로도 돌아가야한다.
      // teacher : 이것을 실행하면 스스로가 여기까지는 이해했다고 하는 보증이 생긴다.
      // teacher : 돌아가는 것을 확인 했기 때문에 밑의 for문과 updatePlanet은 신경 쓸 필요가 없다.
      
    }
    // 결국 이 함수를 실행함으로써 예상되는 결과는
    // 내가 참조하고 싶은 배열(array)에 내가 원하는 위치(index)에 내가 원하는 값(item)을 집어 넣을 수 있을 것이다.
    // 그리고 참조한 배열(array)의 값은 순서가 밀려날 뿐 삭제되진 않는다. 

    

    // 가장 먼저 읽는 1번 행동.
    // 전역변수로서 planets에 배열을 할당.
    let planets = ["공욱재", "미남", "키위"];
    // teacher : 배열 하나 만들어주자.

    // 전역변수로 addItem()함수로 값을 할당받는 updatePlanet을 선언.
    // 여기서 유추할 수 있는 것은 함수를 호출하여 값을 할당받는다는 것으로 return이 된다는 것을 알 수 있다.
    let updatePlanet = addItem(planets, "나 키위 아니야!", 2);
    // teacher : 함수를 호출하는데, 얘를 변수에 담네? 그럼 이건 값인가?
    
    // 반복제어문인 for문을 실행한다. 무언가가 반복될 것이다.
    // for문에 length가 붙었다? 그럼 배열이나 string일 확률이 높다. 무언가 살펴볼려고 하는 것 같다.
    // updatePlanet이 length를 담고 있으니까 문자열이거나 배열일 확률이 높다.
    for(let i = 0; i < updatePlanet.length ; i++){
      // 어차피 값을 할당받는 것이기 때문에 함수자체를 넣어도 상관은 없구나?
      // 왜냐하면 함수가 return하는게 배열이니까.
      // teacher : 문자열이거나, 배열일 확률이 높다. 숫자가 들어간다. 그럼 문자열이거나 배열이다. 판단 근거 포인트.
      console.log(updatePlanet[i]);
      // teacher : 콘솔로그를 반복해서 찍으려고 하는구나? 값이 뭔지는 모르겠어. 근데 length값이래 실제로 뭐가 찍힐지도 몰라.
      // teacher : 일단 로그가 찍히긴 해.
    }
    // teacher : 해결할 것을 모두 해결했다. 그럼 역순으로 돌아가자. addItem()은 뭐지?
  </script>
</body>
</html>